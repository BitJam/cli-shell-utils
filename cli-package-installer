#!/bin/bash

#==============================================================================
# cli-package-installer
#
# A simple cli wrapper around apt-get and apt-cache to provide some of the
# functionality of Synaptic on the command line.
#
# (C) 2017 Paul Banham <antiX@operamail.com>
# License: GPLv3 or later
#==============================================================================

MAIN_TITLE="antiX CLI Package Installer"

        ME=${0##*/}
    MY_DIR=$(dirname "$(readlink -f $0)")
MY_LIB_DIR=$(readlink -f "$MY_DIR/../cli-shell-utils")
   LIB_DIR="/usr/local/lib/cli-shell-utils"

  LIB_PATH="$MY_LIB_DIR:$LIB_DIR"
      PATH="$MY_LIB_DIR/bin:$LIB_DIR/bin:$PATH"
 SHELL_LIB="cli-shell-utils.bash"

    LIST_DIR=/var/lib/apt/lists
  SOURCE_DIR=/etc/apt/sources.list.d
   LOCK_FILE=$LIST_DIR/lock

  THE_LOG_FILE=/var/log/$ME.log

AUTO_UPDATE_INTERVAL="5"  # Days

    WORK_DIR=/tmp/$ME
    FOUND_MATCH_FILE=$WORK_DIR/found-match

       SEARCH_FILE=$WORK_DIR/SEARCH-RESULTS
           DB_FILE=$WORK_DIR/all.list
    INSTALLED_FILE=$WORK_DIR/installed.list

MARK_CNT=0
: ${EDITOR:=name}


BAR_80="#=============================================================================="

start_testing_mode() {

    TEST_DIR=Private/apt
    SOURCE_DIR=$TEST_DIR/sources.d
    LIST_DIR=$TEST_DIR/lists

    THE_LOG_FILE=$ME.log
    LOG_FILE=$ME.log
    #PRETEND_MODE=true

    ARCH="i386"

    #- search_for() {
    #-     local str=$1

    #-     grep -Eh "$str" $TEST_DIR/full.list
    #- }

    list_installed() {
        cat $TEST_DIR/installed.list
    }

    list_all() {
        cat $TEST_DIR/full.list
    }
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
main() {
    testing || need_root

    BACK_TO_MAIN="go back to main menu"

    local UPGRADE_CNT

    case $(uname -m) in
          i686) ARCH="i386"  ;;
        x86_64) ARCH="amd64" ;;
    esac

    testing && start_testing_mode

    trap on_exit EXIT

    testing || do_flock
    shout $"Starting %s" "$ME"
    start_log "$*"

    find_man_page
    mkdir -p $WORK_DIR || fatal "Could not create directory %s" "$WORK_DIR"

    msg "Checking to see if an %s is needed ..." "$(pq apt-get update)"

    local NO_DB_GENERATE=true

    while true; do
        run_outer check_list_files && break

    done

    NO_DB_GENERATE=

    generate_db_file

    msg "$BAR_80"
    shout "$MAIN_TITLE"
    msg "$BAR_80"

    do_search

    while true; do
        do_main_menu
    done
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_main_menu() {

    msg
    msg "$BAR_80"
    shout "$MAIN_TITLE"
    msg "$BAR_80"

    local title=$"Main Menu"
    local ans

    run_outer my_select 'ans' "$title" "$(main_menu)"

    case $ans in
              search) do_search       ;;
              update) do_update       ;;
             upgrade) do_upgrade_menu ;;
                edit) do_source_menu  ;;
           view-mark) view_marked     ;;
        install-mark) install_marked  ;;
          unmark-all) unmark_all      ;;
                quit) exit            ;;

        *)  warn "The '%s' feature isn't implemented yet" "$(pqw $ans)"
            msg "Press <Enter> to continue"
            read ans ;;
    esac
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
main_menu() {
    local upgrade_lab
    : ${UPGRADE_CNT:=$(count_upgrades)}

    menu_printf search    "Search for and install packages"
    menu_printf standard  "Select a common search from a list"
    menu_printf package   "Select packages to install from a list"
    menu_printf update    "Update package index"

    if [ $MARK_CNT -gt 0 ]; then
        local mcnt=$(pnh $MARK_CNT)
        menu_printf    view-mark "View %s marked package(s)"        "$mcnt"
        menu_printf install-mark "Install %s marked package(s)"     "$mcnt"
        menu_printf   unmark-all "Unmark all %s marked package(s)"  "$mcnt"
    fi

    if [ $UPGRADE_CNT -gt 0 ]; then
        menu_printf upgrade "Do a system upgrade (%s packages)" "$(pnh $UPGRADE_CNT)"
    fi

    menu_printf edit      "Edit the source files"
    menu_printf quit      "Quit"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_source_menu() {

    while true; do
        shout "Edit-Source Menu"
        local ans  title="Please select a source file to edit"
        my_select ans "$title" "$(source_menu)"
        case $ans in
            quit) break ;;
        esac
        local file=$ans
        if ! test -e "$file"; then
            warn "Could not find file %s to edit" "$(pqw $file)"
            continue
        fi
        nano "$file"
    done
    echo
    check_list_files
}

#------------------------------------------------------------------------------
# Create a menu for editing source files
#------------------------------------------------------------------------------
source_menu() {

    local file
    for file in $SOURCE_DIR/*.list; do
        test -e "$file" || continue
        menu_printf "$file" "$(basename "$file")"
    done
    menu_printf quit "Back to Main"
}

#------------------------------------------------------------------------------
# Display a package name and description in a nice way and indicate if the
# package is installed and/or marked
#------------------------------------------------------------------------------
show_package() {
    local match=$1  width=$(screen_width)  attrib
    local max_width=$((width - 5))
    [ -z "$match" ] && return
    if [ -z "${match##M*}" ]; then
        attrib="$attrib${attrib:+ }(${mark_co}marked$nc_co)"
        match=${match#M}
    fi
    if [ -z "${match##I*}" ]; then
        attrib="$attrib${attrib:+ }(${inst_co}installed$nc_co)"
        match=${match#I}
    fi
    match=${match# }

    arrow_msg "$hi_co%s" "${match:0:$max_width}"
    [ "$attrib" ] && echo "$attrib"
}

#------------------------------------------------------------------------------
# This is the core routine of this program.  I try to make good use of the
# limited flow control in Shell, "break", "continue", "return" which is why
# this routine has too many nested loops and not enough modularized calls
# to smaller functions.
#------------------------------------------------------------------------------
do_search() {

    # This loop is for doing new searches.  Maybe there is a better way in
    # order to avoid so much nesting
    while true; do
        shout
        shout "Search for Packages"
        local all_str
        get_glob_string all_str

        case $all_str in
            [qQ]) return ;;
        esac

        [ -z "$all_str" ] && return


        # This loop is to repeat viewing of the same search results.  In here
        # a 'break' gets you to a new search and a 'continue' will reshow the
        # same results

        while true; do

            local desc_str=${all_str#^}
            desc_str=${desc_str%$}
            local name_str="${all_str}[^ ]* - "
            local lead_str="^([MI]+ )?${desc_str#^}"
            local exact_str="${lead_str%$} - "

            local exact_cnt=   lead_cnt=    name_cnt=    desc_cnt=
            local exact_match= lead_match=  name_match=  desc_match=

            local TOTAL_MATCHES=0  FOUND_MATCH=
            count_matches  exact "exact name match"           "exact name matches"
            count_matches  lead  "leading name match"         "leading name matches"
            count_matches  name  "any name match"             "any name matches"
            count_matches  desc  "name or description match"  "name or description matches"

            if [ $TOTAL_MATCHES -eq 0 ]; then
                warn "No matches were found"
                YES_no "Do you want to try a different search?" && continue
                return
            fi

            # Need to use a file because the commands below are in a subshell
            rm -f $FOUND_MATCH_FILE
            local result_menu=$(
                add_to_result_menu exact "exact"
                add_to_result_menu lead  "leading"
                add_to_result_menu name  "total name"
                add_to_result_menu desc  "description"
            )

            echo

            local found_match
            read found_match 2>/dev/null <$FOUND_MATCH_FILE

            local menu_result the_string
            shout "Search Result Menu"
            local result_title="Please select an action"
            my_select 'menu_result' "$result_title" "$result_menu"
            [ -z "$menu_result" ] && continue

            local action=${menu_result#*-}
            local search_type=${menu_result%%-*}

            case $action in
                  view) ;;
                  mark)      mark_package "$found_match" ; continue ;;
                unmark)    unmark_package "$found_match" ; continue ;;
               install)   install_package "$found_match" ; continue ;;
             uninstall) uninstall_package "$found_match" ; continue ;;
                  quit) return ;;
                     *) fatal "Internal error in search result menu %s" "$action" ;;
            esac

            eval the_string=\$${search_type}_str

            search_for "$the_string" > $SEARCH_FILE
            local cnt=$(wc -l $SEARCH_FILE | cut -d" " -f1)

            local height=$(screen_height)
            if [ $cnt -lt $((height - 5)) ]; then
                cat $SEARCH_FILE | number_results | less -EXRS
            else
                local blanks=$((height - 5))
                (local i; for i in $(seq 1 $blanks); do echo; done)  > $SEARCH_FILE.nl
                cat $SEARCH_FILE | number_results                   >> $SEARCH_FILE.nl


                msg "%s packages were found." $cnt
                msg
                quest "In the next step you will been shown a list of packages that you can scroll\n"
                quest "Use <up-arrow>, <down-arrow>, <page-up>, and <page down> to scroll the list\n"
                quest "Position the package you want near the bottom and then press 'q' to continue\n"
                msg
                quest "press <Enter> to see the list, %s to go the main menu, %s to do another search" \
                    "$(pqq q)" "$(pqq s)"

                local ans
                read ans
                case $ans in
                    [qQ]*) return ;;
                    [sS]*) break  ;;
                esac

                # Never start with blank lines under the last line
                local offset=$((blanks + 1))
                [ $((offset + height)) -gt $((blanks + cnt + 2)) ] && offset=$((cnt + blanks - height + 2))

                less -RXSm +$offset $SEARCH_FILE.nl

            fi

            # This loop is to repeat the 'number' input if needed.
            # The action variable helps us to figure out what to do in the surounding loop
            local action
            while true; do
                Msg "Please enter the number of the package you want to install"
                Msg "Use %s to go to main menu, %s to search again, %s to see the results again" \
                    "$(bq q)" "$(bq s)" "$(bq r)"

                local number
                read -p "> " number

                case $number in
                       "") continue ;;
                    [qQ]*) return   ;;
                    [rR]*) action=review ; break ;;
                    [sS]*) action=search ; break ;;
                    [1-9]|[1-9][0-9]|[1-9][0-9][0-9]) ;;
                                [1-9][0-9][0-9][0-9]) ;;
                           [1-9][0-9][0-9][0-9][0-9]) ;;
                      [1-9][0-9][0-9][0-9][0-9][0-9]) ;;
                    *) warn "Invalid input.  Please try again" ; continue ;;
                esac

                if [ "$number" -gt $cnt ]; then
                    warn "That number was out of range, please try again"
                    continue
                fi

                break
            done

            case $action in
                review) continue ;;
                search) break    ;;
            esac

            local full_package=$(nl $SEARCH_FILE | sed -n -r "s/^\s*$number\s*//p")
            if [ -z "$full_package" ]; then
                warn "Could not find package number %s" "$number"
                break
            fi

            show_package "$full_package"

            local menu=$(
                mark_or_install_menu "$full_package"
                menu_printf search $"Search again"
                menu_printf quit "$Back to main menu"
            )

            my_select 'ans' "Please select an action" "$menu"

            case $ans in
                  mark)      mark_package "$full_package" ; break ;;
                unmark)    unmark_package "$full_package" ; break ;;
               install)   install_package "$full_package" ; break ;;
             uninstall) uninstall_package "$full_package" ; break ;;
                search) break  ;;
                  quit) return ;;
                     *) fatal "Internal error in 2nd search result menu %s" "$ans" ;;
            esac

            my_select 'ans' "Now what?" "$(bottom_search_menu)"

            case $ans in
                 search) break                          ;;
                 review) continue                       ;;
                   quit) return                         ;;
                      *) fatal "Internal install menu error %s" "$ans" ;;
            esac
        done
    done
}

#------------------------------------------------------------------------------
# Use the "nl" program to prefix each line with a number and then use sed to
# colorize the lines and put parens aroud the leading M and/or I.
#------------------------------------------------------------------------------
number_results() {
    sed -r -e "s/^(MI)(.*)/$mark_co(M${inst_co}I$mark_co)\2$nc_co/" \
           -e "s/^(M)(.*)/$mark_co(\1)\2$nc_co/"  \
           -e "s/^(I)(.*)/$inst_co(\1)\2$nc_co/"  \
        | nl \
        | sed -r "s/^(\s*[0-9]+)\s/$cyan\1$green)$nc_co /"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
bottom_search_menu() {
    menu_printf search  "Do a new search"
    menu_printf review  "See search results again"
    menu_printf quit    "Return to main menu"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
install_package() {
    local full=$1  pack=$(package_name "$1")
    msg "Installing %s" "$(pq $pack)"
    apt_get_cmd install "$pack"
    update_db_package $pack
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
uninstall_package() {
    local ans  full=$1  pack=$(package_name "$1")
    msg
    shout "Remove / Purge Menu"
    local ans
    my_select ans "Please choose an action for this package" "$(remove_menu)"
    case $ans in
            remove) apt_get_cmd remove  $pack ;;
             purge) apt_get_cmd purge   $pack ;;
           install) apt_get_cmd install $pack ;;
         reinstall) apt_get_cmd --reinstall install $pack ;;
              quit) return  ;;
                 *) fatal "internal remove_menu error %s" "$ans" ;;
    esac
    update_db_package
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
apt_get_cmd() {
    local cmd="apt-get $*"
    msg "=> %s" "$cmd"
    $cmd && return 0
    warn "The command %s failed" "$(pqw $cmd)"
    return 1
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
remove_menu() {
    menu_printf remove    "Uninstall package (remove package but not its config files)"
    menu_printf purge     "Purge package (remove package AND its confi files)"
    menu_printf reinstall "Reinstall package (even if it is up to date)"
    menu_printf install   "Install package (only if it is not up to date)"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
get_glob_string() {
    local var_nam=$1
    local line1="Please enter the term you want to search for."
    local line2=$(printf "Standard globbing wildcards '%s' and '%s' work." "$(bqq '*')" "$(bqq '?')")
    local line3=$(printf "Use an empty string or '%s' to return to main menu." "$(bqq 'q')")

    title=$(printf "%s\n%s\n%s\n" "$line1" "$line2" "$line3")

    local input prompt=$(quest "> ")
    quest "$title"
    echo -en "\n$prompt"
    read -r input

    # Convert '*' and '?' to their regular expression equivalents
    # First protect "." in the original string
    input=${input//./\\.}
    input=${input//\?/.}
    input=${input//\*/.*}

    eval $var_nam=\$input
}

#------------------------------------------------------------------------------
# Count and display the number of matches for various search criteria.
#------------------------------------------------------------------------------
count_matches() {
    local prefix=$1  lab1=$2  lab2=$3  found="Found"
    eval local str=\$${prefix}_str

    local cnt=$(search_for "$str" | wc -l | cut -d" " -f1)

    eval ${prefix}_cnt=\$cnt

    local fmt="  %s $num_co%5s$m_co %s"
    TOTAL_MATCHES=$((TOTAL_MATCHES + $cnt))
    if [ $cnt -eq 1 ]; then
        local match=$(search_for "$str")
        # FIXME: count lines and warn/error on -ne 1
        # Also make sure length is not zero
        eval ${prefix}_match=\$match

        msg "$fmt"  "$found"  "$cnt"  "$lab1"
        if [ -z "$FOUND_MATCH" ]; then
            FOUND_MATCH=true
            show_package "$match"
        fi
    else
        msg "$fmt" "$found" "$cnt" "$lab2"
    fi
}


#------------------------------------------------------------------------------
# Uses information from in count_matches() to create menu entries for each
# type of search result.  If there are no matches, do nothing, the first time
# there is only one match then offer to install/unintall or mark/unmark that
# package.  If there is more than one match then offer to let the user view
# those matches.
#------------------------------------------------------------------------------
add_to_result_menu() {
    local prefix=$1  lab=$2
    local cnt match
    eval cnt=\$${prefix}_cnt
    case $cnt in
        0)  return ;;
        1)  test -e $FOUND_MATCH_FILE && return

            eval match=\$${prefix}_match
            local package=$(package_name "$match")
            echo "$package" > $FOUND_MATCH_FILE

            mark_or_install_menu "$match" "$prefix-"

            ;;

        *)  menu_printf "$prefix-view" "View %s %s results" "$(nq $cnt)"  "$lab"  ;;
    esac
}

#------------------------------------------------------------------------------
# This generates two menu entries for marking/unmarking a package and for
# isntalling/uninstalling it.
#------------------------------------------------------------------------------
mark_or_install_menu() {
    local match=$1  prefix=$2
    local package=$(package_name "$match")
    local pq_pack=$(pq $package)

    if is_marked "$match"; then
        menu_printf "${prefix}unmark"   "Unmark package %s"  "$pq_pack"
    else
        menu_printf "${prefix}mark"     "Mark package %s"    "$pq_pack"
    fi

    if is_installed "$match"; then
        menu_printf "${prefix}uninstall" "Uninstall package %s" "$pq_pack"
    else
        menu_printf "${prefix}install"   "Install package %s"   "$pq_pack"
    fi
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
is_marked() {
    local match=$1
    [ -z "${match##M*}" ]
    return $?
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
is_installed() {
    local match=$1
    [ -z "${match##I*}" -o -z "${match##MI*}" ]
    return $?
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
search_for() {
    local str=$1 iflag=i

    # Any uppercase letter causes case sensitive search
    [ -z "${str##*[A-Z]*}" ] && iflag=
    grep -Eh$iflag "$str" $DB_FILE
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
list_depends() {
    local pack=$(package_name "$1")
    apt-cache depends $pack | sed -n -r "s/^\s*Depends:\s*//"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
package_name() {
    echo ${1%% - *} | sed -r "s/^[MI]+ //"
}


#==============================================================================
# Check to see if all (most) list files exist as expected
#==============================================================================

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
check_list_files() {
    src_dir=${1:-$SOURCE_DIR}  list_dir=${2:-$LIST_DIR}

    local LIST_ERR_CNT=0  LIST_FOUND_CNT=0  LIST_OLDEST_T=999999999999

    local type url repo other root
    local ext

    while read type url repo other; do
        [ -n "$type" ] || continue
        case $repo in
            *updates) continue ;;
            *) ;;
        esac
        root=${url#*://}
        root=${root//\//_}

        #echo "$type $root $repo $other"
        root=${root%_}_dists_$repo

        local full=$list_dir/$root

        if [ "$type" = "deb" ]; then
            ext="_binary-${ARCH}_Packages"
            find_list_file ${full}_InRelease \
                || find_list_file ${full}_Release \
                || list_error "${root}_Release or ${root}_InRelease"

            for part in $other; do
                test_list_file ${full}_$part$ext
            done

        elif [ "$type" = "deb-src" ]; then
            ext="_source_Sources"
            for part in $other; do
                test_list_file ${full}_$part$ext
            done
        fi

    done << Read_Sources
$(grep -h "^\s*\(deb\|deb-src\)\>" $src_dir/*.list)
Read_Sources

    local now_t=$(date +%s)
    local max_interval=$((AUTO_UPDATE_INTERVAL * 60 * 60 * 24))
    local interval=$(($(date +%s) - LIST_OLDEST_T))
    local days=$((interval / 60 / 60 / 24))

    (
        echo
        printf  "      Found list files: %s\n"  "$LIST_FOUND_CNT"
        printf  "    Missing list files: %s\n"  "$LIST_ERR_CNT"
        printf  " Oldest list file time: %s\n"  "$LIST_OLDEST_T"
        printf  "  Seconds since update: %s\n"  "$interval"
        printf  "     Days since update: %s\n"  "$days"
        echo
    ) >> $LOG_FILE

    local apt_get=$(pq apt-get update)
    local run_now=$(printf "Run %s now?" "$apt_get")

    if [ $LIST_FOUND_CNT -eq 0 ]; then
        Msg "No list files were found"
        Msg "An %s is required in order to continue" "$apt_get"
        # FIXME BACK_TO_MAIN
        YES_no "$run_now" || return 1

    elif [ $LIST_ERR_CNT -gt 0 ]; then
        Msg "It appears that at least one list file is missing"
        Msg "You should probably run %s now" "$apt_get"
        YES_no "$run_now" || return 0

#--    elif [ $interval -gt $max_interval ]; then
#--        Msg "At least one list file is at least %s day(s) old" "$days"
#--        Msg "You should probably run %s now" "$apt_get"
#--        YES_no "$run_now" || return
    else
        return 0
    fi

    do_update
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
find_list_file() {
    local file=$1

    test -e $file || return 1
    local modded=$(stat -c %Y $file)
    LIST_FOUND_CNT=$((LIST_FOUND_CNT + 1))
    [ $LIST_OLDEST_T -gt $modded ] && LIST_OLDEST_T=$modded
    return 0
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
test_list_file() {
    #echo "  $(basename $1)"
    find_list_file $1 || list_error $(basename $1)
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
list_error() {
    local name=$1
    LIST_ERR_CNT=$((LIST_ERR_CNT + 1))
    echo "Missing list file(s): $name" >> $LOG_FILE
}

#=== End of List File Stuff ===================================================

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_update() {
    msg "Doing %s" "$(pq apt-get update)"

    if ! apt-get update; then
        warn "There was a problem running %s" "$(pqw apt-get update)"
        yes_NO "Do you want to continue anyway" || return 1
    fi
    UPGRADE_CNT=
    check_for_upgrades
    generate_db_file
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
generate_db_file() {
    [ "$NO_DB_GENERATE" ] && return
    msg "Updating database file ..."
    local start_t=$(get_time)
    local db=${1:-$DB_FILE}   installed=${2:-$INSTALLED_FILE}
    list_installed > $installed
    list_all | mark-installed-debs $installed > $db
    msg "%s took %s second(s)" "$(pq generate db file)" "$(pnq $(show_delta_t $start_t))"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
update_db_package() {
    local pack=$1
    if really_is_installed $pack; then
        mark_installed $pack
    else
        mark_uninstalled $pack
    fi
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
really_is_installed() {
    local status  pack=$1
    status=$(dpkg-query -f '${db:Status-Status}' --show "$pack" 2>/dev/null) \
        || return 1
    [ "$status" = 'installed' ]
    return $?
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
mark_uninstalled() {
    local pack=$1  db=${2:-$DB_FILE}
    sed -i -r -e "s/^I ($pack - )/\1/" -e "s/^MI ($pack - )/M \1/" $db
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
mark_installed() {
    local pack=$1  db=${2:-$DB_FILE}
    sed -i -r -e "s/^($pack - )/I \1/"  -e "s/^M ($pack - )/MI \1/" $db
}

#------------------------------------------------------------------------------
# Mark a package and all uninstalled dependencies
#------------------------------------------------------------------------------
mark_package() {
    local pack=$(package_name "$1")  db=${2:-$DB_FILE}
    _mark_package "$pack"

    testing && return

    local dep  deps=$(list_depends "$pack")
    msg "found %s dependencies" "$(nq $(echo $deps | wc -w))"
    local regex=$(echo "$deps" | tr ' ' '|')
    local cnt=$(egrep --count "^($regex) - " $db)
    arrow_msg "Marking %s dependencies" "$(nq $cnt)"
    sed -i -r "s/^($regex) - /M \1 - /" $db
    MARK_CNT=$((MARK_CNT + cnt))
}

#------------------------------------------------------------------------------
# Mark a single package if it is not already marked
#------------------------------------------------------------------------------
_mark_package() {
    local pack=$1  db=${2:-$DB_FILE}

    # Don't mark an already marked package
    egrep -q "^(I )?$pack - " $db || return

    arrow_msg "Mark package %s" "$(pq $pack)"
    sed -i -r -e "s/^I ($pack - )/MI \1/" -e "s/^($pack - )/M \1/" $db
    MARK_CNT=$((MARK_CNT + 1))
}

#------------------------------------------------------------------------------
# Umark a single package if it is marked
#------------------------------------------------------------------------------
unmark_package() {
    local pack=$(package_name "$1")  db=${2:-$DB_FILE}
    grep -q "^MI? $pack - " $db && return

    arrow_msg "Unmark package %s" "$(pq $pack)"
    sed -i -r -e "s/^M(I $pack - )/\1/" -e "s/^M ($pack - )/\1/" $db
    MARK_CNT=$((MARK_CNT - 1))
}


#------------------------------------------------------------------------------
# Unmark all packages
#------------------------------------------------------------------------------
unmark_all() {
    local pack=$1  db=${2:-$DB_FILE}
    local cnt=$(grep --count "^M" $db)

    arrow_msg "Unmarking %s package(s)" "$(nq $cnt)"
    sed "s/^M ?//" $db
    MARK_CNT=0
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
list_all() {  apt-cache search . | sort; }

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
list_installed() { dpkg-query --show | sort | cut -f1; }

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
count_upgrades() { apt list --upgradable 2>/dev/null | grep -v "^Listing" | wc -l;  }

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
check_for_upgrades() {
    msg "Checking for package upgrades ..."
    UPGRADE_CNT=$(count_upgrades)
    if [ $UPGRADE_CNT -eq 0 ]; then
        msg "Nothing to upgrade"
        return
    fi
    msg "There are %s packages that can be upgraded" "$(nq $UPGRADE_CNT)"
    do_upgrade_menu 3
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_upgrade_menu() {
    local default_entry=$1

    : ${UPGRADE_CNT:=$(count_upgrades)}
    if [ $UPGRADE_CNT -eq 0 ]; then
        warn "There are no packages to upgrade"
        return
    fi

    while true; do
        shout "Package Upgrade Menu"
        local ans
        my_select ans "Please select an action" "$(upgrade_menu $UPGRADE_CNT)" "" $default_entry
        case $ans in
             ignore) return              ;;
               quit) return              ;;
            upgrade) do_upgrade ; return ;;
               view) view_upgrades       ;;
                  *) fatal "Internal error: upgrade_menu: %s" $ans ;;
        esac
    done
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
upgrade_menu() {
    local cnt=${1:-$UPGRADE_CNT}

    menu_printf  upgrade "Upgrade %s packages now" "$(pnq $cnt)"
    menu_printf  view    "View list of packages to be upgraded"
    menu_printf  ignore  "Ignore these upgrades for now"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
view_upgrades() {
    # FIXME: Use UPGRADE_CNT to optimize how we use "less".
    apt list --upgradable | less
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_upgrade() {
    apt_get_cmd upgrade || return
    generate_db_file
}

arrow_msg() {
    local fmt=$1 ; shift
    msg "$(bq "==>") $fmt" "$@"
}

#------------------------------------------------------------------------------
# Set BACK_TO_MAIN as an empty local variable.  This affects how we deal with
# the user pressing 'q' when we are waiting for input.
#------------------------------------------------------------------------------
run_outer() { local BACK_TO_MAIN= ; "$@" ; }

#------------------------------------------------------------------------------
# Start logging by appending a simple header
#------------------------------------------------------------------------------
start_log() {
    local args=$1 cmds=${2# }

    LOG_FILE=$THE_LOG_FILE

    cat <<Start_Log >> $LOG_FILE
---------------------------------------------------------------------
$0
        started: $(date)
        version: $VERSION ($VERSION_DATE)
    comand line: $args
      found lib: $FOUND_LIB
     TEXTDOMAIN: $TEXTDOMAIN
  TEXTDOMAINDIR: $TEXTDOMAINDIR
     SOURCE_DIR: $SOURCE_DIR
       LIST_DIR: $LIST_DIR

Start_Log
}

screen_height() { stty size | cut -d" " -f1; }
screen_width()  { stty size | cut -d" " -f2; }

testing() { [ -n "$TEST" ]; return $?; }

#------------------------------------------------------------------------------
# Load the lib either from a neighboring repo or from the standard location.
#------------------------------------------------------------------------------
load_lib() {
    local file=$1  path=$2
    unset FOUND_LIB

    local dir lib found IFS=:
    for dir in $path; do
        lib=$dir/$file
        test -r $lib || continue
        if ! . $lib; then
            printf "Error when loading library %s\n" "$lib" >&2
            printf "This is a fatal error\n" >&2
            exit 15
        fi
        FOUND_LIB=$lib
        return 0
    done

    printf "Could not find library '%s' on path '%s'\n" "$file" "$path" >&2
    printf "This is a fatal error\n" >&2
    exit 17
}

set_my_colors() {
    set_colors
    inst_co=$cyan
    mark_co=$yellow
}

on_exit() {
    testing || unflock
}

#===== Start Here =============================================================

load_lib "$SHELL_LIB" "$LIB_PATH"

set_my_colors

main "$@"
