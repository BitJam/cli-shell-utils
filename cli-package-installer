#/bin/bash

#==============================================================================
# cli-package-installer
#
# A simple cli wrapper around apt-get and apt-cache to provide some of the
# functionality of Synaptic on the command line.
#
# (C) 2017 Paul Banham <antiX@operamail.com>
# License: GPLv3 or later
#==============================================================================

        ME=${0##*/}
    MY_DIR=$(dirname "$(readlink -f $0)")
MY_LIB_DIR=$(readlink -f "$MY_DIR/../cli-shell-utils")
   LIB_DIR="/usr/local/lib/cli-shell-utils"

  LIB_PATH="$MY_LIB_DIR:$LIB_DIR"
     PATH="$MY_LIB_DIR/bin:$LIB_DIR/bin:$PATH"
SHELL_LIB="cli-shell-utils.bash"

 LIST_DIR=/var/lib/apt/lists
  SOURCE_DIR=/etc/apt/sources.list.d

  THE_LOG_FILE=/var/log/$ME.log

AUTO_UPDATE_INTERVAL="5"  # Days

    WORK_DIR=/tmp/$ME

       SEARCH_FILE=$WORK_DIR/SEARCH-RESULTS
           DB_FILE=$WORK_DIR/all.list
    INSTALLED_FILE=$WORK_DIR/installed.list

: ${EDITOR:=name}


start_testing_mode() {

    TEST_DIR=Private/apt
    SOURCE_DIR=$TEST_DIR/sources.d
    LIST_DIR=$TEST_DIR/lists

    THE_LOG_FILE=$ME.log
    LOG_FILE=$ME.log
    #PRETEND_MODE=true

    ARCH="i386"

    #- search_for() {
    #-     local str=$1

    #-     grep -Eh "$str" $TEST_DIR/full.list
    #- }

    list_installed() {
        cat $TEST_DIR/installed.list
    }

    list_all() {
        cat $TEST_DIR/full.list
    }
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
main() {
    testing || need_root

    BACK_TO_MAIN="go back to main menu"

    local UPGRADE_CNT

    case $(uname -m) in
          i686) ARCH="i386"  ;;
        x86_64) ARCH="amd64" ;;
    esac

    testing && start_testing_mode

    shout $"Starting %s" "$ME"
    start_log "$*"

    find_man_page
    mkdir -p $WORK_DIR || fatal "Could not create directory %s" "$WORK_DIR"

    msg "Checking to see if an %s is needed ..." "$(pq apt-get update)"

    NO_DB_UPDATE=true
    run_outer check_list_files
    NO_DB_UPDATE=

    update_db_file

    while true; do
        do_main_menu
    done
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_main_menu() {

    msg
    shout "antiX CLI Package Installer"
    local title=$"Main Menu"
    local ans

    run_outer my_select 'ans' "$title" "$(main_menu)"

    case $ans in
        search) do_search       ;;
        update) do_update       ;;
       upgrade) do_upgrade_menu ;;
          edit) do_source_menu  ;;
          quit) exit            ;;
          *) warn "The '%s' feature isn't implemented yet" "$(pqw $ans)"
             msg "Press <Enter> to continue"
             read ans ;;
    esac

}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
main_menu() {
    local upgrade_lab  fmt="%s$P_IFS%s\n"
    : ${UPGRADE_CNT:=$(count_upgrades)}
    #testing && UPGRADE_CNT=10

    [ ${UPGRADE_CNT:-0} -gt 0 ] \
        && upgrade_lab=$(printf "Do a system upgrade (%s packages)" "$(pnh $UPGRADE_CNT)")

    printf "$fmt" search    "Search for and install packages"
    printf "$fmt" standard  "Select a common search from a list"
    printf "$fmt" package   "Select packages to install from a list"
    printf "$fmt" update    "Update package index"

    [ "$upgrade_lab" ] && printf "$fmt" upgrade "$upgrade_lab"

    printf "$fmt" edit      "Edit the source files"
    printf "$fmt" quit      "Quit"
}


#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_source_menu() {

    while true; do
        shout "Edit-Source Menu"
        local ans  title="Please select a source file to edit"
        my_select ans "$title" "$(source_menu)"
        case $ans in
            quit) break ;;
        esac
        local file=$ans
        if ! test -e "$file"; then
            warn "Could not find file %s to edit" "$(pqw $file)"
            continue
        fi
        nano "$file"
    done
    echo
    check_list_files
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
source_menu() {

    local fmt="%s$P_IFS%s\n"

    local file  name
    for file in $SOURCE_DIR/*.list; do
        test -e "$file" || continue
        local name=$(basename $file)
        printf "$fmt" "$file" "$name"
    done
    printf "$fmt" quit "Back to Main"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
count_matches() {
    local prefix=$1  lab1=$2  lab2=$3  found="Found"
    eval local str=\$${prefix}_str

    local cnt=$(search_for "$str" | wc -l | cut -d" " -f1)

    eval ${prefix}_cnt=\$cnt

    local fmt="  %s $num_co%5s$m_co %s"
    TOTAL_MATCHES=$((TOTAL_MATCHES + $cnt))
    if [ $cnt -eq 1 ]; then
        local match=$(search_for "$str")
        # FIXME: count lines and warn/error on -ne 1
        # Also make sure length is not zero
        local installed=
        [ -z "${match##I *}" ] && installed="$red(installed)$nc_co\n"
        match=${match#I }
        eval ${prefix}_match=\$match

        msg "$fmt"            "$found"  "$cnt" "$lab1"
        show_package "$match"
        printf "$installed"
    else
        msg "$fmt"            "$found" "$cnt" "$lab2"
    fi
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
show_package() {
    local pack=$1  width=$(screen_width)
    local max_width=$((width - 5))
    printf "$bold_co==> $hi_co%s$nc_co\n" "${pack:0:$max_width}"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_search() {

    # This loop is for doing new searches.  Maybe there is a better way in
    # order to avoid so much nesting
    while true; do
        shout
        shout "Search for Packages"
        local all_str
        get_glob_string all_str

        case $all_str in
            [qQ]) return ;;
        esac

        [ -z "$all_str" ] && return
        local desc_str=${all_str#^}
        desc_str=${desc_str%$}
        local name_str="${all_str}.* - "
        local lead_str="^(I )?${desc_str#^}"
        local exact_str="${lead_str%$} - "

        local exact_cnt=   lead_cnt=    name_cnt=    desc_cnt=
        local exact_match= lead_match=  name_match=  desc_match=

        local TOTAL_MATCHES=0
        count_matches  exact "exact name match"           "exact name matches"
        count_matches  lead  "leading name match"         "leading name matches"
        count_matches  name  "any name match"             "any name matches"
        count_matches  desc  "name or description match"  "name or description matches"

        if [ $TOTAL_MATCHES -eq 0 ]; then
            warn "No matches were found"
            YES_no "Do you want to try a different search?" && continue
            return
        fi

        local result_menu=$(
            add_to_result_menu exact "exact"
            add_to_result_menu lead  "leading"
            add_to_result_menu name  "total name"
            add_to_result_menu desc  "description"
        )

        echo

        local result_prefix the_string
        shout "Search Result Menu"
        local result_title="Please select an action"
        my_select 'result_prefix' "$result_title" "$result_menu"
        [ -z "$result_prefix" ] && continue

        case $result_prefix in
            quit) return ;;
            desc) SEARCH_ARGS= ;;
               *) SEARCH_ARGS=--names-only ;;
        esac

        eval the_string=\$${result_prefix}_str
        eval the_match=\$${result_prefix}_match

        search_for "$the_string" > $SEARCH_FILE
        local cnt=$(wc -l $SEARCH_FILE | cut -d" " -f1)

        case $cnt in
            1) do_install "$the_match" ; return ;;
        esac

        # This loop is to repeat viewing of the same search results.  In here
        # a 'break' gets you to a new search and a 'continue' will reshow the
        # same results

        while true; do

            local height=$(screen_height)
            if [ $cnt -lt $((height - 5)) ]; then
                cat $SEARCH_FILE | number_results
            else
                local blanks=$((height - 5))
                (local i; for i in $(seq 1 $blanks); do echo; done)  >  $SEARCH_FILE.nl
                cat $SEARCH_FILE | number_results                   >> $SEARCH_FILE.nl

                msg "%s packages were found." $cnt
                msg
                quest "In the next step you will been shown a list of packages that you can scroll\n"
                quest "Use <up-arrow>, <down-arrow>, <page-up>, and <page down> to scroll the list\n"
                quest "Position the package you want near the bottom and then press 'q' to continue\n"
                msg
                quest "press <Enter> to see the list, 'q' to go the main menu, 's' to do another search"

                local ans
                read ans
                case $ans in
                    [qQ]*) return ;;
                    [sS]*) break  ;;
                esac

                # Never start with blank lines under the last line
                local offset=$((blanks + 1))
                [ $((offset + height)) -gt $((blanks + cnt + 2)) ] && offset=$((cnt + blanks - height + 2))

                less -RXSm +$offset $SEARCH_FILE.nl

            fi

            # This loop is to repeat the 'number' input if needed.
            # The action variable helps us to figure out what to do in the surounding loop
            local action
            while true; do
                Msg "Please enter the number of the package you want to install"
                Msg "Use 'q' to go to main menu, 's' to search again, 'r' to see the list again"

                local number
                read -p "> " number

                case $number in
                       "") continue ;;
                    [qQ]*) return   ;;
                    [rR]*) action=review ; break ;;
                    [sS]*) action=search ; break ;;
                    [1-9]|[1-9][0-9]|[1-9][0-9][0-9]) ;;
                                [1-9][0-9][0-9][0-9]) ;;
                           [1-9][0-9][0-9][0-9][0-9]) ;;
                      [1-9][0-9][0-9][0-9][0-9][0-9]) ;;
                    *) warn "Invalid input.  Please try again" ; continue ;;
                esac

                if [ "$number" -gt $cnt ]; then
                    warn "That number was out of range, please try again"
                    continue
                fi

                break
            done

            case $action in
                review) continue ;;
                search) break    ;;
            esac

            local full_package=$(nl $SEARCH_FILE | sed -nr "s/^\s*$number\s*(I\s*)?//p")
            if [ -z "$full_package" ]; then
                warn "Could not find package number %s" "$number"
                break
            fi
            local scr_width=$(screen_width)

            do_install $full_package

            my_select 'ans' "Now what?" "$(bottom_search_menu)"

            case $ans in
                 search) break                          ;;
                 review) continue                       ;;
                   quit) return                         ;;
                      *) fatal "Internal install menu error %s" "$ans"
            esac
        done
    done
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
number_results() {
    sed -r "s/^(I)(.*)/$cyan(\1)\2$nc_co/" \
        | nl \
        | sed -r "s/^(\s*[0-9]+)\s/$cyan\1$green)$nc_co /"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
bottom_search_menu() {
    local fmt="%s$P_IFS%s\n"
    printf "$fmt" search  "Do a new search"
    printf "$fmt" review  "See search results again"
    printf "$fmt" quit    "Return to main menu"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_install() {
    local full=$1  pack=$(package_name "$1")

    show_package "$full"

    if ! testing && ! apt-cache search "^$pack$" &>/dev/null; then
        warn "Cannot find package %s to install!" "$(pqw $pack)"
        return

    elif grep -q "^$pack$" $INSTALLED_FILE; then
        do_remove_purge_reinstall "$full"
        return

    else
        local label=$(printf "Install package %s" "$(pqq $pack)")
        YES_no "$label" || return
    fi

    msg "Installing %s" "$(pq $pack)"
    apt_get_cmd install "$pack" && mark_installed $pack
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_remove_purge_reinstall() {
    local ans  full=$1  pack=$(package_name "$1")
    warn "Package %s is already installed" "$(pqw $pack)"
    msg
    warn "Remove / Purge Menu"
    my_select "Please choose an action for this package" "$(remove_menu)"
    case $ans in
            remove) apt_get_cmd remove $pack ;;
             purge) apt_get_cmd purge  $pack ;;
           install) apt_get_cmd install $pack ;;
         reinstall) apt_get_cmd --reinstall install $pack ;;
                 *) fatal "internal remove_menu error %s" "$ans"
    esac
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
apt_get_cmd() {
    local cmd="$*"
    msg "=> %s" "$cmd"
    $cmd && return 0
    warn "The command %s failed" "$(pqw $cmd)"
    return 1
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
remove_menu() {
    local fmt="%s$P_IFS%s\n"
    printf "$fmt" remove    "Uninstall package (remove package but not its config files)"
    printf "$fmt" purge     "Purge package (remove package AND its confi files)"
    printf "$fmt" reinstall "Reinstall package (even if it is up to date)"
    printf "$fmt" install   "Instal package (only if it is not up to date)"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
get_glob_string() {
    local var_nam=$1
    local title="Please enter the term you want to search for."
    title=$(printf "$title\n%s" "Standard globbing wildcards '*' and '?' work.")
    title=$(printf "$title\n%s" "Use an empty string or 'q' to return to main menu.")

    local input prompt=$(quest "> ")
    quest "$title"
    echo -en "\n$prompt"
    read -r input

    # Convert '*' and '?' to their regular expression equivalents
    input=${input//\?/.}
    input=${input//\*/.*}

    eval $var_nam=\$input
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
add_to_result_menu() {
    local prefix=$1  lab=$2
    local cnt match
    eval cnt=\$${prefix}_cnt
    eval match=\$${prefix}_match
    local package=$(package_name "$match")
    case $cnt in
        0) return ;;
        1) printf "%s${P_IFS}Install package %s\n" "$prefix" "$(pq "$package")"         ;;
        *) printf "%s${P_IFS}View %s %s results\n" "$prefix" "$(nq $cnt)"       "$lab"  ;;
    esac
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
#- search_for() {
#-     local str=$1
#-     #echo "apt-cache $SEARCH_ARGS $search $str" >&2
#-     apt-cache $SEARCH_ARGS search "$str"
#- }

search_for() {
        local str=$1
        grep -Eh "$str" $DB_FILE
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
package_name() { echo ${1%% - *}; }


#==============================================================================
# Check to see if all (most) list files exist as expected
#==============================================================================

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
check_list_files() {
    src_dir=${1:-$SOURCE_DIR}  list_dir=${2:-$LIST_DIR}

    local LIST_ERR_CNT=0  LIST_FOUND_CNT=0  LIST_OLDEST_T=999999999999

    local type url repo other root
    local ext

    while read type url repo other; do
        [ -n "$type" ] || continue
        case $repo in
            *updates) continue ;;
            *) ;;
        esac
        root=${url#*://}
        root=${root//\//_}

        #echo "$type $root $repo $other"
        root=${root%_}_dists_$repo

        local full=$list_dir/$root

        if [ "$type" = "deb" ]; then
            ext="_binary-${ARCH}_Packages"
            find_list_file ${full}_InRelease \
                || find_list_file ${full}_Release \
                || list_error "${root}_Release or ${root}_InRelease"

            for part in $other; do
                test_list_file ${full}_$part$ext
            done

        elif [ "$type" = "deb-src" ]; then
            ext="_source_Sources"
            for part in $other; do
                test_list_file ${full}_$part$ext
            done
        fi

    done << Read_Sources
$(grep -h "^\s*\(deb\|deb-src\)\>" $src_dir/*.list)
Read_Sources

    local now_t=$(date +%s)
    local max_interval=$((AUTO_UPDATE_INTERVAL * 60 * 60 * 24))
    local interval=$(($(date +%s) - LIST_OLDEST_T))
    local days=$((interval / 60 / 60 / 24))

    (
        echo
        printf  "      Found list files: %s\n"  "$LIST_FOUND_CNT"
        printf  "    Missing list files: %s\n"  "$LIST_ERR_CNT"
        printf  " Oldest list file time: %s\n"  "$LIST_OLDEST_T"
        printf  "  Seconds since update: %s\n"  "$interval"
        printf  "     Days since update: %s\n"  "$days"
        echo
    ) >> $LOG_FILE

    local apt_get=$(pq apt-get update)
    local run_now=$(printf "Run %s now?" "$apt_get")

    if [ $LIST_FOUND_CNT -eq 0 ]; then
        Msg "No list files were found"
        Msg "An %s is required in order to continue" "$apt_get"
        # FIXME BACK_TO_MAIN
        YES_no "$run_now" || exit

    elif [ $LIST_ERR_CNT -gt 0 ]; then
        Msg "It appears that at least one list file is missing"
        Msg "You should probably run %s now" "$apt_get"
        YES_no "$run_now" || return

#--    elif [ $interval -gt $max_interval ]; then
#--        Msg "At least one list file is at least %s day(s) old" "$days"
#--        Msg "You should probably run %s now" "$apt_get"
#--        YES_no "$run_now" || return
    else
        return
    fi

    do_update
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
find_list_file() {
    local file=$1

    test -e $file || return 1
    local modded=$(stat -c %Y $file)
    LIST_FOUND_CNT=$((LIST_FOUND_CNT + 1))
    [ $LIST_OLDEST_T -gt $modded ] && LIST_OLDEST_T=$modded
    return 0
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
test_list_file() {
    #echo "  $(basename $1)"
    find_list_file $1 || list_error $(basename $1)
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
list_error() {
    local name=$1
    LIST_ERR_CNT=$((LIST_ERR_CNT + 1))
    echo "Missing list file(s): $name" >> $LOG_FILE
}

#=== End of List File Stuff ===================================================

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_update() {
    msg "Doing %s" "$(pq apt-get update)"

    if ! apt-get update; then
        warn "There was a problem running %s" "$(pqw apt-get update)"
        yes_NO "Do you want to continue anyway" || return
    fi
    UPGRADE_CNT=
    check_for_upgrades
    update_db_file
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
update_db_file() {
    [ "$NO_DB_UPDATE" ] && return
    msg "Updating database file ..."

    local db=${1:-$DB_FILE}   installed=${2:-$INSTALLED_FILE}
    list_installed > $installed
    list_all | mark-installed-debs $installed > $db
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
unmark_installed() {
    local pack=$1  db=${2:-$DB_FILE} installed=${3:-$INSTALLED_FILE}
    sed -ir "s/^I ($pack$)\1//" $db
    sed -i "/^$pack$/d" $installed
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
mark_installed() {
    local pack=$1  db=${2:-$DB_FILE} installed=${2:-$INSTALLED_FILE}
    sed -i "/^$pack$/ s/^/I /" $db
    echo "$pack" >> $installed
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
list_all() {  apt-cache search . | sort; }

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
list_installed() { dpkg-query --show | sort | cut -f1; }

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
count_upgrades() { apt list --upgradable 2>/dev/null | grep -v "^Listing" | wc -l;  }

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
check_for_upgrades() {
    msg "Checking for package upgrades ..."
    UPGRADE_CNT=$(count_upgrades)
    if [ $UPGRADE_CNT -eq 0 ]; then
        msg "Nothing to upgrade"
        return
    fi
    msg "There are %s packages that can be upgraded" "$(nq $UPGRADE_CNT)"
    do_upgrade_menu 3
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_upgrade_menu() {
    local default_entry=$1

    : ${UPGRADE_CNT:=$(count_upgrades)}
    if [ $UPGRADE_CNT -eq 0 ]; then
        warn "There are no packages to upgrade"
        return
    fi

    while true; do
        shout "Package Upgrade Menu"
        local ans
        my_select ans "Please select an action" "$(upgrade_menu $UPGRADE_CNT)" "" $default_entry
        case $ans in
             ignore) return              ;;
               quit) return              ;;
            upgrade) do_upgrade ; return ;;
               view) view_upgrades       ;;
                  *) fatal "Internal error: upgrade_menu: %s" $ans
        esac
    done
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
upgrade_menu() {
    local cnt=${1:-$UPGRADE_CNT}
    local fmt="%s$P_IFS%s\n"

    local lab=$(printf "Upgrade %s packages now" "$(pnq $cnt)")
    printf "$fmt" upgrade "$lab"
    printf "$fmt" view    "View list of packages to be upgraded"
    printf "$fmt" ignore  "Ignore these upgrades for now"
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
view_upgrades() {
    # FIXME: Use UPGRADE_CNT to optimize how we use "less".
    apt list --upgradable | less
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
do_upgrade() {
    apt_get_cmd upgrade && NO_DB_UPDATE= update_db_file
}

#------------------------------------------------------------------------------
# Set BACK_TO_MAIN as an empty local variable.  This affects how we deal with
# the user pressing 'q' when we are waiting for input.
#------------------------------------------------------------------------------
run_outer() { local BACK_TO_MAIN= ; "$@" ; }

#------------------------------------------------------------------------------
# Start logging by appending a simple header
#------------------------------------------------------------------------------
start_log() {
    local args=$1 cmds=${2# }

    LOG_FILE=$THE_LOG_FILE

    cat <<Start_Log >> $LOG_FILE
---------------------------------------------------------------------
$0
        started: $(date)
        version: $VERSION ($VERSION_DATE)
    comand line: $args
      found lib: $FOUND_LIB
     TEXTDOMAIN: $TEXTDOMAIN
  TEXTDOMAINDIR: $TEXTDOMAINDIR
     SOURCE_DIR: $SOURCE_DIR
       LIST_DIR: $LIST_DIR

Start_Log
}


screen_height() { stty size | cut -d" " -f1; }
screen_width()  { stty size | cut -d" " -f2; }

testing() { [ -n "$TEST" ]; return $?; }

#------------------------------------------------------------------------------
# Load the lib either from a neighboring repo or from the standard location.
#------------------------------------------------------------------------------
load_lib() {
    local file=$1  path=$2
    unset FOUND_LIB

    local dir lib found IFS=:
    for dir in $path; do
        lib=$dir/$file
        test -r $lib || continue
        if ! . $lib; then
            printf "Error when loading library %s\n" "$lib" >&2
            printf "This is a fatal error\n" >&2
            exit 15
        fi
        FOUND_LIB=$lib
        return 0
    done

    printf "Could not find library '%s' on path '%s'\n" "$file" "$path" >&2
    printf "This is a fatal error\n" >&2
    exit 17
}

#===== Start Here =============================================================

load_lib "$SHELL_LIB" "$LIB_PATH"

set_colors

main "$@"
